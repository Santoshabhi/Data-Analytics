# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WnGtXODyE1BcPg9Gjohv1VMAYBt0DOjR

Imputation

Imputation is the process of replacing missing data with substituted values.

In data science and statistics, datasets often have gapsâ€”cells where information was not recorded or was lost. Because most machine learning algorithms cannot process blank values (NaN/Null), you must handle them. Instead of deleting the entire row or column (which loses valuable information), imputation fills these gaps with estimated values.

The goal of imputation is not just to "fill the hole," but to do so in a way that preserves the overall statistical relationships (like the mean, variance, and correlations) of the dataset.
"""

import numpy as np
import pandas as pd

# Create a sample dataset
data = {
    'Age': [25, 27, 29, np.nan, 32, 35, np.nan, 40, 42, 45],
    'Salary': [50000, 54000, 58000, 60000, np.nan, 65000, 70000, 72000, 75000, np.nan],
    'Experience': [1, 2, 3, 4, 5, np.nan, 7, 8, 9, 10]
}

df = pd.DataFrame(data)
print("Original DataFrame with Missing Values:")
print(df)

"""1. Simple Imputation (Univariate)

**Concept: **This is the most basic approach. You replace missing values with a summary statistic of that column (mean, median, mode) or a constant value. It treats every feature independently.

Mean: Good for normally distributed numerical data.

Median: Better if the data has outliers.

Most Frequent (Mode): Used for categorical data.

"""

from sklearn.impute import SimpleImputer

# Create a copy of the dataframe to keep the original safe
df_simple = df.copy()

# Initialize the imputer (strategy can be 'mean', 'median', 'most_frequent', 'constant')
imputer = SimpleImputer(strategy='mean')

# Fit and transform the data
# Note: output is a numpy array, so we convert it back to DataFrame
df_simple_imputed = pd.DataFrame(imputer.fit_transform(df_simple), columns=df_simple.columns)

print("\n--- Simple Imputation (Mean) ---")
print(df_simple_imputed)

"""2. K-Nearest Neighbors (KNN) ImputationConcept:

This method finds the k rows (neighbors) that are most similar to the row with the missing value. It then averages the values of those neighbors to fill the gap.

This is often more accurate than simple imputation because it accounts for the correlation between rows.

Key Parameter: n_neighbors (the number of neighbors to use).

"""

from sklearn.impute import KNNImputer

df_knn = df.copy()

# Initialize KNN Imputer
# n_neighbors=3 means it looks at the 3 most similar rows
knn_imputer = KNNImputer(n_neighbors=3)

df_knn_imputed = pd.DataFrame(knn_imputer.fit_transform(df_knn), columns=df_knn.columns)

print("\n--- KNN Imputation ---")
print(df_knn_imputed)

"""3. Multivariate Imputation by Chained Equations (MICE)

Concept: Also known as Iterative Imputation. This is a sophisticated method that models each feature with missing values as a function of other features.

It fills missing values with a placeholder (e.g., mean).

It treats the column with missing values as the "target" and runs a regression model (like BayesianRidge) using other columns as features to predict the true value.

It repeats this process multiple times until the values converge.

"""

from sklearn.experimental import enable_iterative_imputer  # Explicitly enable
from sklearn.impute import IterativeImputer

df_mice = df.copy()

# Initialize MICE Imputer
# random_state ensures reproducibility
mice_imputer = IterativeImputer(max_iter=10, random_state=0)

df_mice_imputed = pd.DataFrame(mice_imputer.fit_transform(df_mice), columns=df_mice.columns)

print("\n--- MICE (Iterative) Imputation ---")
print(df_mice_imputed)

"""4. Time-Series Imputation (Forward/Backward Fill)

Concept: If your data is time-series data (ordered by time), using the mean is dangerous because it ignores trends. instead, we propagate the last known value forward or the next valid value backward.

FFill (Forward Fill): Takes the previous valid value and fills it forward.

BFill (Backward Fill): Takes the next valid value and fills it backward.

"""

df_time = df.copy()

# Forward Fill
df_ffill = df_time.ffill()

# Backward Fill
df_bfill = df_time.bfill()

# Linear Interpolation (Connecting the dots)
# This assumes a linear relationship between time steps
df_interp = df_time.interpolate(method='linear')

print("\n--- Time Series: Linear Interpolation ---")
print(df_interp)